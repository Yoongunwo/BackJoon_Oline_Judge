BackJoon_Oline_Judge
=============

---
Algorithm
=============
### 유클리드 호제법 
1. 개요
    - 두 양의 정수, 혹은 두 다항식의 최대공양수를 구하는 방법으로   
   두 양의 정수 a,b (a > b)에 대하여 a = bq + r ( 0 <= r < b )이라 하면, a,b의 최대공약수는 b,r의 최대공약수와 같다. 즉,   
   <div align="center">gcd(a,b) = gcd(b,r)</div>     
   　　r = 0이라면 a,b의 최대공약수는 b가 된다.
2. 소스코드
```java
int gcd(int a, int b)
{
    int r = a % b;
    if ( r == 0 ) {
      return b;
    }
    return gcd(b,r)
}
```

### 백트래킹
1. 정의
    - 모든 경우의 수를 전부 고려하는 알고리즘. 상태공간을 트리로 나타낼 수 있을 때 적합한 방식이다. 
    일종의 트리 탐색 알고리즘이라고 봐도 된다. 방식에 따라서 DFS, BFS, Best First Search(Heuristic 
    Search)이 있다. 
   
2. 적용
    - 백트래킹은 모든 가능한 경우의 수 중에서 특정한 조건을 만족하는 경우만 살펴 보는 것이다.
    - 즉 답이 될만한지 판단하고 그렇지 않으면 그 부분까지 탐색하는 것을 하지 않고 가지치기하는 것을
    백트래킹이라고 생각하면 된다.
    - 주로 물제 풀이에서는 DFS 등으로 모든 경우의 수를 탐색하는 과정에서 조건문 등을 걸어 답이 절대
    로 될 수 없는 상황을 저으이하고, 그러한 상황일 경우에는 탐색을 중지시킨 뒤 그 이전으로 돌아가서 
    다시 다른 경우를 탐색하게끔 구현할 수 있다.


### 다이나믹 프로그래밍
#### 1. 정의
- DP, 즉 다이나믹 프로그래밍(또는 동적 계획법)은 기본적인 아이디어로 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 것으로 특정한 알고리즘이 아닌 하나의 문제해결 패러다임으로 볼 수 있다.
    __큰 문제를 작은 문제로 쪼개서 그 답을 저장해두고 재활용__ 한다. 그래서 혹자는 DP가 아닌 '기억하며 풀기'라고 부르기도 한다.

#### 2. 적용
- 사실 일반적인 재귀방식 또한 DP와 매우 유사하다. 큰 차이점은 __일반적인 재귀를 단순히 사용 시 동일한 작은 문제들이 여러 번 반복 되어 비효율적인 계산이 될 수 있다는 것이다. 그러나 한 번 구한 작은 결과 값을 저장해두고 재사용 한다면 어떨까? 앞에서 계산된 값을 반복할 필요가 없이 계산이 가능해진다. 따라서 시간복잡도를 기준으로 다음과 같이 개선이 가능하다 
<div align="center">O(n^2) → O(f(n))</div> 

#### 3. 조건
##### 3.1 Overlapping Subproblems
- DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구한다. 그래서 __동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능__ 하다
##### 3.2 Optimal Substructure(최적 부분 구조)
- __부분문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우__ 를 의미한다. 그래서 특정 문제의 정답은 문제의 크기에 상관없이 항상 동일하다.

#### 4. 구현방법
##### 4.1 Buttom-Up 방식 
- __아래에서부터 계산을 수행하고 누적시켜서 전체 큰 문제를 해결하는 방식__ 이다.
- 메모를 위해서 dp라는 배열을 만들었고 이것이 1차원이라 가정했을 때, dp[0]이 기저 상태이고, dp[n]을 목표 상태라고 하자. Buttom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 재활용하는 방식이다.
- Tabulation : Button-up일 때는 Tabulation이라고 부른다. 왜냐면 반복을 통해 dp[0]부터 하나 하나씩 채우느 과정을 "table-filling"히며, 이 Table에 저장된 값에 직접 접근하여 재활용하므로 Tabulation이라는 명칭이 붙었다고 한다. 사실상 결과값을 기억하고 재활용한다는 측면에서 메모하기(Memorization)와 크게 다르지 않다.

##### 4.2 Top_Down 방식
- 이는 dp[0]의 기저 상태에서 출발하는 대신 dp[0]의 값을 찾기 위해 __위에서 부터 바로 호출을 시작__ 하여 dp[0]의 상태까지 내려간 다음 해당 __결과 값을 재귀를 통해 전이시켜 재활용하는 방식__ 이다. 이 때, 이미 이전에 계산이 완료한 경우에는 단순히 메모리에 저장되어 있던 내역을 꺼내서 활용하면 된다. 그래서 가장 최근의 상태 값을 메모해 두었다고 하여 Memorization이라고 부른다.
---
## ref:
* "BackJoon Oline Judge" acmicpc.net https://www.acmicpc.net/
* "유클리드 호제법," namu.wiki, https://namu.wiki/w/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C%20%ED%98%B8%EC%A0%9C%EB%B2%95
* "백트래킹," namu.wiki, https://namu.wiki/w/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9
* "알고리즘-백트래킹(Backtracking)의 정의 및 예시문제," chanhuiseok.github.io, https://chanhuiseok.github.io/posts/algo-23/
